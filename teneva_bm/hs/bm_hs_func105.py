import numpy as np
from teneva_bm import Bm


class BmHsFunc105(Bm):
    def __init__(self, d=8, n=64, seed=42, name=None):
        super().__init__(d, n, seed, name)
        self.set_desc("""
            The function 105 from the Hock & Schittkowski collection.
            Continuous optimal control (OC) problem with constraints:
            .-------------------------------------.
            | F(x | p, t) -> min s.t. C(x) = True |
            .-------------------------------------.
            p - parameters
                mypi = 4 * atan(1)
                y = [0, 95, 105, 110, 110, 110, 110, 115, 115, 115, 115, 120, 120, 120,
                    120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 125, 125, 
                    125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 130, 
                    130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 
                    135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 140, 
                    140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 
                    140, 140, 140, 140, 140, 140, 145, 145, 145, 145, 145, 145, 145, 145, 
                    145, 145, 145, 145, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 
                    150, 150, 150, 150, 150, 150, 150, 155, 155, 155, 155, 160, 160, 160, 
                    160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 
                    160, 160, 160, 165, 165, 165, 165, 165, 165, 165, 165, 170, 170, 170, 
                    170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 
                    175, 175, 175, 175, 175, 175, 175, 175, 180, 180, 180, 180, 180, 180, 
                    185, 185, 185, 185, 185, 185, 190, 190, 190, 190, 190, 190, 190, 195, 
                    195, 195, 195, 200, 200, 200, 205, 205, 205, 210, 210, 210, 210, 210, 
                    210, 210, 210, 215, 220, 220, 220, 220, 220, 220, 230, 230, 230, 230, 
                    230, 235, 240, 240, 240, 240, 240, 240, 240, 245, 250, 250]
            x - continuous control
                x[0] | >= 0.001 | <= .499
                x[1] | >= 0.001 | <= .499
                x[2] | >= 100   | <= 180
                x[3] | >= 130   | <= 210
                x[4] | >= 170   | <= 240
                x[5] | >= 5     | <= 25
                x[6] | >= 5     | <= 25
                x[7] | >= 5     | <= 25
            t - intermediates
                a = (x[0] / x[5]) * exp(-(y - x[2]) ** 2 / (2 * x[5] ** 2))
                b = (x[1] / x[6]) * exp(-(y - x[3]) ** 2 / (2 * x[6] ** 2))
                c = ((1 - x[1] - x[0]) / x[7]) * exp(-(y - x[4]) ** 2 / (2 * x[7] ** 2))
            F - objective function
                - sum(log((a + b + c) / sqrt(2 * mypi)))
            C - constraint function
                1 - x[0] - x[1] >= 0
            The exact global minimum is approx. known:
                y ~= 1136.307
                x[0] ~= 0.353
                x[1] ~= 0.499
                x[2] ~= 130.246
                x[3] ~= 163.058
                x[4] ~= 222.767
                x[5] ~= 11.878
                x[6] ~= 19.537
                x[7] ~= 16.415
            Hyperparameters: 
                * The dimension d should be 8
                * The mode size n may be any (default is 64)
                * The default limits for function inputs are [-10, 10].
        """)

        self.set_grid([0.001, 0.001, 100, 130, 170, 5, 5, 5], [0.499, 0.499, 180, 210, 240, 25, 25, 25])
        self.set_constr(penalty=1.E+3, eps=1.E-2, with_amplitude=True)
        self.set_parameters()

    @property
    def args_constr(self):
        return {'d': 8}

    @property
    def identity(self):
        return ['n']

    @property
    def is_func(self):
        return True

    @property
    def with_constr(self):
        return True

    def set_parameters(self):
        self.parameters = {
            'mypi': 4 * np.arctan(1),
            'y': np.array([
                0, 95, 105, 110, 110, 110, 110, 115, 115, 115, 115, 120, 120, 120, 
                120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 125, 125, 
                125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 130, 
                130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 
                135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 135, 140, 
                140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 
                140, 140, 140, 140, 140, 140, 145, 145, 145, 145, 145, 145, 145, 145, 
                145, 145, 145, 145, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 
                150, 150, 150, 150, 150, 150, 150, 155, 155, 155, 155, 160, 160, 160, 
                160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 
                160, 160, 160, 165, 165, 165, 165, 165, 165, 165, 165, 170, 170, 170, 
                170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 
                175, 175, 175, 175, 175, 175, 175, 175, 180, 180, 180, 180, 180, 180, 
                185, 185, 185, 185, 185, 185, 190, 190, 190, 190, 190, 190, 190, 195, 
                195, 195, 195, 200, 200, 200, 205, 205, 205, 210, 210, 210, 210, 210, 
                210, 210, 210, 215, 220, 220, 220, 220, 220, 220, 230, 230, 230, 230, 
                230, 235, 240, 240, 240, 240, 240, 240, 240, 245, 250, 250
            ])
        }

    def intermediates(self, X):
        y = self.parameters['y'][None, :]
        X = X[:, :, None]
        a = (X[:, 0] / X[:, 5]) * np.exp(-(y - X[:, 2]) ** 2 / (2 * X[:, 5] ** 2))
        b = (X[:, 1] / X[:, 6]) * np.exp(-(y - X[:, 3]) ** 2 / (2 * X[:, 6] ** 2))
        c = ((1 - X[:, 1] - X[:, 0]) / X[:, 7]) * np.exp(-(y - X[:, 4]) ** 2 / (2 * X[:, 7] ** 2))
        return a, b, c

    def constr_batch(self, X):
        return -1 * (1 - X[:, 0] - X[:, 1])

    def target_batch(self, X):
        a, b, c = self.intermediates(X)
        return - (np.log((a + b + c) / np.sqrt(2 * self.parameters['mypi']))).sum(-1)